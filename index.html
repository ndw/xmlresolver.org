<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Welcome to XMLResolver.org</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700" />
<link rel="stylesheet" href="home.css" />
</head>
<body>
<h1 class="title">Welcome to XMLResolver.org</h1>
<p>As you can tell from the clever name, this site is about an XML
  Resolver. (The code is <a href="http://github.com/ndw/xmlresolver/">over on github</a>.)
  Many (Java-based) XML APIs include features for &#8220;resolvers&#8221; of various
  sorts. For example, many XML parsers allow you to define a &#8220;entity
  resolver&#8221; that can intercept attempts to load system identifiers.
  Schema processors provide a &#8220;URI resolver&#8221; that lets you intercept
  schema module URIs. Stylesheet and query processors have similar APIs
  for intercepting stylesheet and query modules.</p>
<p>The resolver APIs exist because it’s sometimes useful in applications
  to return a locally cached resource instead of the resource actually
  requested. It’s a significant feature of the web that you can
  dereference the URI</p>
<pre class="src">
http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd
</pre>
<p>and find out that it’s the DTD for XHTML. It is not, however,
  <b>desireable</b> that <b>everyone</b> should <b>always</b> dereference that URI to
  get the XHTML DTD. It hasn’t changed in more than a decade and there’s
  no reason to believe it will <b>ever change again</b>.</p>
<p>I know, DTDs are unfashionable and XHTML has measles or some other
  disease against which the world should have been vaccinated, but I chose
  that example with care. The W3C web server gets <b>so many</b> requests for
  the XHTML DTD that it goes out of its way to make retrieving it painful.</p>
<p>Go ahead, download that DTD. You’ll find that the server introduces a
  significant delay before returning the data and if you get it
  often enough they’ll lock you out for 24 hours or something.</p>
<p>Point being: there are lots of URIs which you can usefully cache
  locally.</p>
<p>There are basically two approaches to local caching: you can setup
  a proxy server and have it cache things for you, or you can use
  <a href="http://xmlcatalogs.org">XML Catalogs</a>. Oh, I don’t dispute there might be other
  approaches, but those are the two common, obvious ones.</p>
<p>The advantage of the local caching proxy is that it’s automatic. It
  caches the resources you request according to whatever criteria you
  establish, it works transparently in the background. No muss, no fuss.
  Well, except for the fact that you have to install and setup a local
  caching proxy. You have to use it everywhere. You might have to chain
  it together with your corporate caching proxy. You also have to
  configure the criteria for local caching. I find its advantages are a
  lot more theoretical than practical.</p>
<p>The XML Resolver project is about doing it with catalogs.</p>
<h2>XML Catalogs</h2>
<p>Catalogs are straightforward, you provide an XML document that has
  mappings from identifiers that might appear in documents to local
  resources that should be returned for those identifiers.</p>
<p>Here’s an example:</p>
<pre class="src">
&lt;catalog xmlns=&quot;urn:oasis:names:tc:entity:xmlns:xml:catalog&quot;&gt;
  &lt;system systemId=&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;
          uri=&quot;/share/dtds/xhtml1-strict.dtd&quot;/&gt;
&lt;/catalog&gt;
</pre>
<p>If you load that catalog, attempts to obtain the XHTML DTD from the W3C
  will be satisfied by a local copy of the DTD obtained from the
  <code>/share/dtds/xhtml1-strict.dtd</code>.</p>
<h2>How to use XML Resolver</h2>
<p>The simplest possible thing you can do is instantiate an instance of
  <code>org.xmlresolver.Resolver</code> and use it as the resolver for your parser.
  The <code>Resolver</code> class implements the following resolvers:</p>
<ul>
  <li><code>org.xml.sax.EntityResolver</code> the SAX1 interface used to load XML entities</li>
  <li><code>org.xml.sax.EntityResolver2</code> the SAX2 interface used to load XML entities</li>
  <li><code>javax.xml.transform.URIResolver</code> used to load XSLT resources</li>
  <li><code>org.w3c.dom.ls.LSResourceResolver</code> used by the DOM to load resources</li>
  <li><code>org.xmlresolver.NamespaceResolver</code> an interface for loading namespace-based
    resources based or <a href="https://en.wikipedia.org/wiki/RDDL(RDDL)">RDDL</a> that never
    really took off, but there you go.</li>
</ul>
<p>Another simple integration point is to instantiate
  <code>org.xmlresolver.tools.ResolvingXMLReader</code> as your XML parser.</p>
<h3>Configuring XML Resolver</h3>
<p>The Resolver classes use either Java system properties or a standard
  Java properties file to establish an initial environment. The property
  file, if it is used, must be called <code>xmlresolver.properties</code> and must
  be somewhere on your CLASSPATH.footnote:[For backwards
  compatibility, the name <code>catalogmanager.properties</code> may also be used.
  Use the system property <code>xmlresolver.properties</code> to specify a
  name (or, technically, a semicolon separated list of names) explicitly.]</p>
<p>The resolver searches for a property file by looking in the following places,
  in this order:</p>
<ul>
  <li>The <code>xmlresolver.properties</code> system property</li>
  <li>The <code>XMLRESOLVER_PROPERTIES</code> environment variable (new in v0.99.0)</li>
  <li>A file named <code>xmlresolver.properties</code> on your classpath.</li>
</ul>
<p>The following features may be configured with properties.</p>
<h4>The initial list of catalog files</h4>
<ul>
  <li>System property <code>xml.catalog.files</code></li>
  <li>Property file property <code>catalogs</code></li>
</ul>
<p>A semicolon-delimited list of catalog files. These are the catalog
  files that are initially consulted for resolution.</p>
<p>Unless you are
  incorporating the resolver classes into your own applications, and
  subsequently establishing an initial set of catalog files through some
  other means, at least one file must be specified, or all resolution
  will fail.</p>
<h4>Preference for public or system identifiers</h4>
<ul>
  <li>System property <code>xml.catalog.prefer</code></li>
  <li>Property file property <code>prefer</code></li>
</ul>
<p>The initial prefer setting, either public or system.</p>
<h4>Obey <code>oasis-xml-catalog</code> processing instruction</h4>
<ul>
  <li>System property <code>xml.catalog.allowPI</code></li>
  <li>Property file property <code>allow-oasis-xml-catalog-pi</code></li>
</ul>
<p>This setting allows you to toggle whether or not the resolver classes
  obey the <code>&lt;?oasis-xml-catalog?&gt;</code> processing instruction.</p>
<h4>Support relative catalog paths</h4>
<ul>
  <li>Property file property <code>relative-catalogs</code></li>
</ul>
<p>If <code>relative-catalogs</code> is true, relative catalogs in the <code>catalogs</code>
  property list will be left relative; otherwise they will be made
  absolute with respect to the base URI of the properties file from
  which they came.</p>
<p>This setting has no effect on catalogs loaded from the
  <code>xml.catalogs.files</code> system property (which are always returned
  unchanged).</p>
<h4>Cache documents</h4>
<ul>
  <li>System properties <code>xml.catalog.cache</code>, <code>xml.catalog.cacheUnderHome</code></li>
  <li>Property file property <code>cache</code>, <code>cacheUnderHome</code></li>
</ul>
<p>The <code>cache</code> properties specify the directory in which the XML Resolver
  should attempt to cache files that fail to resolve locally. If, instead,
  one of the <code>cacheUnderHome</code> properties is set, the cache directory will
  default to <code>$HOME/.xmlresolver/cache</code>.</p>
<h4>Schemes to cache</h4>
<ul>
  <li>System property ~xml.catalog.cache.~/scheme/</li>
  <li>Property file property ~cache-~/scheme/</li>
</ul>
<p>Specifies whether or not URIs of type <i>scheme</i> will be cached. If not
  specified, the default is “true” for all schemes except <code>file</code>.</p>
<h3>Example catalog properties file</h3>
<p>My <code>XMLResolver.properties</code> file looks like this:</p>
<pre class="src">
# XMLResolver.properties

relative-catalogs=yes

# Always use semicolons in this list
catalogs=./catalog.xml;/home/ndw/Documents/catalog.xml

prefer=public

cache=/Users/ndw/.xmlresolver/cache
</pre>
<h2>See also</h2>
<ul>
  <li>Absent more complete information here, most of
    <a href="https://xerces.apache.org/xml-commons/components/resolver/resolver-article.html">XML Entity and URI Resolvers</a> is still relevant.</li>
  <li><a href="http://xmlcatalogs.org">XML Catalogs</a></li>
</ul>
</body>
</html>
